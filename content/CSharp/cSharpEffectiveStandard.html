<div class="blackBoard">
    <ol>
        <li>
            <dl>
                <dt>类型 & 变量 & 实例</dt>
                <dd>类型：描述对东西的分类</dd>
                <dd>变量：由类型修饰，用于指代实例</dd>
                <dd>实例：具体的东西</dd>
                <dd>变量是程序中使用实例的方式，变量的类型反映出你如何看待该实例</dd>
                <dd>实例当然不会随变量类型而变化</dd>
            </dl>
        </li>

        <li>
            <dl>
                <dt>自定义类型：定义数据 / 定义方法</dt>
                <dd>定义数据的类型：
                    <ul>
                        <li><strong class="label label-info">enum</strong> 区分不同的事物</li>
                        <li><strong class="label label-info">struct</strong> 描述一个事物的组成结构【要支持序列化[Serializable]】</li>
                        <li><strong class="label label-info">class</strong> 描述一个事物的组成结构，和它的行为方式【重写ToString()】</li>
                    </ul>
                </dd>
                <dd>定义方法的类型：
                    <ul>
                        <li><strong class="label label-info">方法常量</strong> 描述如何完成一件事情</li>
                        <li><strong class="label label-info">delegate</strong> 要把一件事情委托给别人</li>
                        <li><strong class="label label-info">event</strong> 要把一件事情通知给大家</li>
                    </ul>
                </dd>
            </dl>
        </li>

        <li>
            <dl>
                <dt>类型转换：as / is / 强转</dt>
                <dd>引用类型，使用as</dd>
                <dd>值类型，使用强转</dd>
                <dd>任何类型的判断，使用is</dd>
            </dl>
        </li>

        <li>
            <dl>
                <dt>契约的种类：接口 / 虚函数 / 回调 / 事件</dt>
                <dd>接口：外部规划契约，由类实现行为</dd>
                <dd>虚函数：父类规划契约并提供默认实现，子类默许或提供新的实现</dd>
                <dd>回调：委托的定义者规划契约，由使用者实现行为</dd>
                <dd>事件：事件的发出者规划契约，由订阅者实现行为</dd>
            </dl>
        </li>

        <li>
            <dl>
                <dt>类的契约：实现 / 继承</dt>
                <dd>实现：按照接口的定义，实现约定的行为</dd>
                <dd>继承：复用基类的所有资源，形成一个“类家族”</dd>
            </dl>
        </li>

        <li>
            <dl>
                <dt>最少知识原则：暴露最少的信息</dt>
                <dd>程序集：隐藏不必要的类
                    <ul>
                        <li><strong class="label label-info">public</strong> 给外部提供服务</li>
                        <li><strong class="label label-info">internal</strong> 为程序集内的其它 类 / 接口 服务</li>
                        <li><strong class="label label-info">private</strong> 内部类，只为某个类服务</li>
                    </ul>
                </dd>
                <dd>类：隐藏不必要的方法成员
                    <ul>
                        <li><strong class="label label-info">public</strong> 给外部提供服务</li>
                        <li><strong class="label label-info">protected</strong> 给子类提供服务</li>
                        <li><strong class="label label-info">private</strong> 不暴露，只为自己服务</li>
                    </ul>
                </dd>
                <dd>属性：隐藏不必要的数据成员
                    <ul>
                        <li>域必须是私有的，通过属性来暴露</li>
                        <li>属性的get和set中能够封装轻量级的逻辑</li>
                        <li>用户将属性看成数据成员，编译器将属性看成方法</li>
                    </ul>
                </dd>
                <dd>暴露范围原则：仅暴露在必须使用到“它”的场合，一定要尽量隐藏</dd>
            </dl>
        </li>

        <li>
            <dl>
                <dt>成员初始化方式：默认值 / 构造函数</dt>
                <dd>调用顺序：静态成员 &rarr; 静态构造函数 &rarr; 实例成员 &rarr; 实例构造函数</dd>
                <dd>如果成员的默认值为0或null，可以不用初始化</dd>
                <dd>默认值简单就使用成员初始化器，如果复杂就使用构造函数</dd>
                <dd>把多个构造函数重复的部分提炼出来，封装到私有构造函数中</dd>
            </dl>
        </li>

        <li>
            <dl>
                <dt>方法的抒写建议</dt>
                <dd>单一职责：结构清晰、逻辑简单，可读性好
                    <ul>
                        <li><strong class="label label-info">程序员</strong> 通过阅读代码，维护程序</li>
                        <li><strong class="label label-info">编译器</strong> 通过阅读代码，优化编译结果</li>
                        <li>因此，我们需要编写清晰、简洁的代码</li>
                    </ul>
                </dd>
                <dd>方法扩展：可选参数 / 重载
                    <ul>
                        <li><strong class="label label-info">重载</strong> 短重载将长重载<ins>多余的参数</ins>固定为默认值</li>
                        <li><strong class="label label-info">可选参数</strong> 把默认值变为可选参数（减少重载数量）</li>
                    </ul>
                </dd>
            </dl>
        </li>

        <li>
            <dl>
                <dt>.Net提供的委托</dt>
                <dd><code>Predict&lt;&gt;</code>：返回 bool类型，自定义 in类型</dd>
                <dd><code>Action&lt;&gt;</code>：返回 void类型，自定义 in类型</dd>
                <dd><code>Func&lt;&gt;</code>：自定义 out类型，自定义 in类型</dd>
            </dl>
        </li>

        <li>
            <dl>
                <dt>使用事件的<ins><a href="#EventCode">标准方式</a></ins></dt>
                <dd>定义事件参数：<code>class TEventArgs: EventArgs</code></dd>
                <dd>定义事件：<code>event EventHandler&lt;TEventArgs&gt;</code> 事件变量</dd>
                <dd>订阅事件：事件变量 += 订阅方法</dd>
                <dd>引发事件：事件变量()</dd>
            </dl>
        </li>

        <li>
            <dl>
                <dt>理解等同性判断：尤其用在集合识别其成员的情况下</dt>
                <dd>值类型struct，应该重写③,④，以提高比较性能</dd>
                <dd>需要用语义区分的引用类型class，应该重写③</dd>
                <dd>重写③必须实现<ins><a href="#IEquatableCode">IEquatable&lt;T&gt;</a></ins>，重载④能够提高程序可读性</dd>
                <dd>①<code>static bool ReferenceEquals(object left, object right)</code> 引用相等</dd>
                <dd>②<code>static bool Equals(object left, object right)</code> 值相等</dd>
                <dd>③<code>virtual bool Equals(object right)</code> 值相等</dd>
                <dd>④<code>static bool operator ==(object left, object right)</code> 值相等</dd>
            </dl>
        </li>

        <li>
            <dl>
                <dt>定义比较规则</dt>
                <dd>类本身支持比较：<ins><a href="#IComparableCode">IComparable&lt;T&gt;</a></ins>
                    <ul>
                        <li><strong class="label label-info">规则内置</strong> 使用<code>int CompareTo(T other)</code>进行比较</li>
                        <li><strong class="label label-info">自然排序方式</strong> 可以使用该逻辑同时重载运算符</li>
                    </ul>
                </dd>
                <dd>专门负责对别人进行比较的类：<ins><a href="#IComparerCode">IComparer&lt;T&gt;</a></ins>
                    <ul>
                        <li><strong class="label label-info">规则单独定义</strong> 常作为委托由<code>Sort()</code>方法调用</li>
                        <li><strong class="label label-info">自定义排序方式</strong> 用于扩展排序规则</li>
                    </ul>
                </dd>
            </dl>
        </li>

        <li>
            <dl>
                <dt>清理非托管资源：using / try...finally</dt>
                <dd>使用非托管资源的类型必须<ins><a href="#IDisposableCode">实现IDisposable</a></ins>，提供清理非托管资源的方法</dd>
                <dd>该类型的使用者负责调用IDisposable，执行清理动作</dd>
                <dd><code>using{ ... }</code>会被编译成<code>try...finally</code>，并在finally中调用IDisposable</dd>
                <dd>若不清楚IDisposable是否被实现，可将对象as成IDisposable，然后using</dd>
            </dl>
        </li>

        <li>
            <dl>
                <dt>清理托管资源：减少冗余对象</dt>
                <dd>在方法中频繁使用，提升为成员变量</dd>
                <dd>在程序中频繁使用，但状态不同，使用享元模式</dd>
                <dd>在程序中频繁使用，状态都相同，使用单件模式</dd>
            </dl>
        </li>

        <li>
            <dl>
                <dt>集合操作：推荐使用Linq</dt>
                <dd>集合操作都是两个步骤：“遍历”，“对元素操作”</dd>
                <dd>Linq已经实现好了遍历，我们只需定义“对元素的操作”（Lambda表达式）</dd>
                <dd>Linq有两种语法形式：查询语法（形似Sql），方法调用语法</dd>
            </dl>
        </li>

        <li>
            <dl>
                <dt>并行遍历集合：PLinq / 并行任务库</dt>
                <dd>条件1：不关注集合中元素的顺序</dd>
                <dd>条件2：集合很庞大</dd>
                <dd>CPU密集时，使用PLinq：<code>集合.AsParallel()</code>【线程数量固定】</dd>
                <dd>I/O密集时，使用并行任务库：<code>Parallel.ForEach()</code>【自动调整线程数量】</dd>
            </dl>
        </li>

        <li>
            <dl>
                <dt>有原子性的值类型，让它保持常量性</dt>
                <dd>原子性：最小的单元，再不能分割</dd>
                <dd>常量性：状态不可变</dd>
                <dd>具有原子性的struct，不能单独修改属性，否则会把它割裂开，变成无意义的数据；所以在它诞生后，状态就一直不可变，成为常量</dd>
                <dd>这样的struct：域为readonly，没有set属性，在get属性中的引用类型成员必须被复制，只能通过构造函数初始化</dd>
            </dl>
        </li>

        <li>
            <dl>
                <dt>更优雅的条件编译：<code>[Conditional("条件编译符号")]</code></dt>
                <dd>用在无返回值的函数上，通过“工程属性/生成/条件编译符号”来配置</dd>
                <dd>好处：方便生成应用的多个版本</dd>
            </dl>
        </li>

        <li>
            <dl>
                <dt>给API传参时，避免类型转换</dt>
                <dd>API的本质是定义消息的功能和格式</dd>
                <dd>经转换的数据，不一定包含消息要求的所有信息，可能会发生错误</dd>
                <dd>多态可以使用，因为子类包含了父类的所有信息</dd>
            </dl>
        </li>

        <li>
            <dl>
                <dt>避免返回对成员的引用：防止被外界修改</dt>
                <dd>用接口指代内部成员：外界只使用内部成员提供的服务</dd>
                <dd>使用包装器：如<code>ReadOnlyCollection&lt;T&gt;</code></dd>
            </dl>
        </li>

        <li>
            <dl>
                <dt>设计Web API时选择合适的粒度</dt>
                <dd>粒度小：通信次数多，数据传输量小（client陷入频繁等待）</dd>
                <dd>粒度大：通信次数少，数据传输量大（一次等待的时间长）</dd>
                <dd>选择合适的粒度，使client每次的等待时间都适中，在合理时间内完成一件事</dd>
            </dl>
        </li>

        <li>
            <dl>
                <dt>慎用ICloneable：会绑架子类，使实现变得复杂</dt>
                <dd>值类型：直接赋值更好</dd>
                <dd>叶子类：可以使用</dd>
                <dd>其它情况：尽量避免使用</dd>
            </dl>
        </li>

        <li>
            <dl>
                <dt>何时应该隐藏基类方法：new</dt>
                <dd>从第三方更新基类后，基类中新增的方法与派生类重名</dd>
                <dd>重名方法已被大量使用，不方便在客户程序中修改</dd>
            </dl>
        </li>

        <li>
            <dl>
                <dt>尽量减少 装箱和拆箱</dt>
                <dd>装箱：值类型 &rarr; Object类型</dd>
                <dd>拆箱：Object类型 &rarr; 值类型</dd>
                <dd>这两个操作非常耗费性能</dd>
            </dl>
        </li>

    </ol>
</div>

<p class="alert">
    注：
    <br />
    1.参考书籍《C#高效编程改进C#代码的50个行之有效的办法(第2版) 中文版》
    <br />
    2.根据自己的理解，对条目进行了合并调整，有些不太理解条目的就省略了
</p>

<a id="EventCode" data-code-url="content/CSharp/EventDemo.txt">标准 event 代码</a>
<a id="IEquatableCode" data-code-url="content/CSharp/IEquatableDemo.txt">标准 IEquatable&lt;T&gt; 代码</a>
<a id="IComparableCode" data-code-url="content/CSharp/IComparableDemo.txt">标准 IComparable&lt;T&gt; 代码</a>
<a id="IComparerCode" data-code-url="content/CSharp/IComparerDemo.txt">标准 IComparer&lt;T&gt; 代码</a>
<a id="IDisposableCode" data-code-url="content/CSharp/IDisposableDemo.txt">标准 IDisposable 代码</a>

