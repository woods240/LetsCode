<div class="blackBoard">
    <ol>
        <li>
            <dl>
                <dt>暴露数据成员：使用属性</dt>
                <dd>域必须是私有的，而属性是公有的</dd>
                <dd>可以在get和set中封装轻量级的逻辑</dd>
                <dd>用户将属性看成数据成员，编译器将属性看成方法</dd>
            </dl>
        </li>

        <li>
            <dl>
                <dt>实现行为：普通函数 / 虚函数 / 回调 / 事件</dt>
                <dd>普通函数：直接实现行为（静态定义）</dd>
                <dd>虚函数：已实现，同时留给子类扩展的权力（静态改变）</dd>
                <dd>回调：由调用者实现（动态实现），只能同时调用一个</dd>
                <dd>事件：由订阅者实现（动态实现），能够同时调用多个</dd>
            </dl>
        </li>

        <li>
            <dl>
                <dt>类型转换：as / is / 强转</dt>
                <dd>引用类型，使用as</dd>
                <dd>值类型，使用强转</dd>
                <dd>任何类型的判断，使用is</dd>
            </dl>
        </li>

        <li>
            <dl>
                <dt>更优雅的条件编译：[Conditional("条件编译符号")]</dt>
                <dd>用在无返回值的函数上，通过“工程属性/生成/条件编译符号”来配置</dd>
                <dd>好处：方便生成应用的多个版本</dd>
            </dl>
        </li>

        <li>
            <dl>
                <dt>轻松显示对象的相关信息</dt>
                <dd>对于自定义的类，重写ToString()</dd>
            </dl>
        </li>

        <li>
            <dl>
                <dt>理解等同性判断：尤其用在集合识别其成员的情况下</dt>
                <dd>值类型struct，应该重写③,④，以提高比较性能</dd>
                <dd>需要用语义区分的引用类型class，应该重写③</dd>
                <dd>重写③必须实现<ins><a href="#IEquatableCode">IEquatable&lt;T&gt;</a></ins>，重载④能够提高程序可读性</dd>
                <dd></dd>
                <dd>①static bool ReferenceEquals(object left, object right) 引用相等</dd>
                <dd>②static bool Equals(object left, object right) 值相等</dd>
                <dd>③virtual bool Equals(object right) 值相等</dd>
                <dd>④static bool operator ==(object left, object right) 值相等</dd>
            </dl>
        </li>

        <li>
            <dl>
                <dt>集合操作：推荐使用Linq</dt>
                <dd>集合操作都是两个步骤：“遍历”，“对元素操作”</dd>
                <dd>Linq已经实现好了遍历，我们只需定义“对元素的操作”（Lambda表达式）</dd>
                <dd>Linq有两种语法形式：查询语法（形似Sql），方法调用语法</dd>
            </dl>
        </li>

        <li>
            <dl>
                <dt>给API传参时，避免类型转换</dt>
                <dd>API的本质是定义消息的功能和格式</dd>
                <dd>经转换的数据，不一定包含消息要求的所有信息，可能会发生错误</dd>
                <dd>多态可以使用，因为子类包含了父类的所有信息</dd>
            </dl>
        </li>

        <li>
            <dl>
                <dt>方法扩展：可选参数 / 重载</dt>
                <dd>在一个重载系列中，短重载将长重载<ins>多余的参数</ins>固定为默认值</dd>
                <dd>如果默认值不会随着版本变化，就把它变为可选参数（可以减少重载数量）</dd>
                <dd>否则，只能使用方法重载</dd>
            </dl>
        </li>

        <li>
            <dl>
                <dt>抒写单一职责的方法</dt>
                <dd>程序员通过阅读代码，维护程序</dd>
                <dd>编译器通过阅读代码，优化编译结果</dd>
                <dd>因此，我们需要编写清晰、简洁的代码</dd>
                <dd>单一职责的方法结构清晰、逻辑简单，可读性好</dd>
            </dl>
        </li>

        <li>
            <dl>
                <dt>成员初始化方式：默认值 / 构造函数</dt>
                <dd>调用顺序：静态成员 &rarr; 静态构造函数 &rarr; 实例成员 &rarr; 实例构造函数</dd>
                <dd>如果成员的默认值为0或null，可以不用初始化</dd>
                <dd>默认值简单就使用成员初始化器，如果复杂就使用构造函数</dd>
                <dd>把多个构造函数重复的部分提炼出来，封装到私有构造函数中</dd>
            </dl>
        </li>

        <li>
            <dl>
                <dt>清理非托管资源：using / try...finally</dt>
                <dd>使用非托管资源的类型必须<ins><a href="#IDisposableCode">实现IDisposable</a></ins>，提供清理非托管资源的方法</dd>
                <dd>该类型的使用者负责调用IDisposable，执行清理动作</dd>
                <dd>using会被编译成try...finally，并在finally中调用IDisposable</dd>
                <dd>若不清楚IDisposable是否被实现，可将对象as成IDisposable，然后using</dd>
            </dl>
        </li>

        <li>
            <dl>
                <dt>配合GC清理托管资源：减少垃圾对象</dt>
                <dd>在方法中频繁使用，提升为成员变量</dd>
                <dd>在程序中频繁使用，但状态不同，使用享元模式</dd>
                <dd>在程序中频繁使用，状态都相同，使用单件模式</dd>
            </dl>
        </li>

        <li>
            <dl>
                <dt>选择数据类型：struct / class / interface</dt>
                <dd>定义数据，使用struct</dd>
                <dd>定义行为，使用interface</dd>
                <dd>实现行为，使用class</dd>
            </dl>
        </li>

        <li>
            <dl>
                <dt>有原子性的值类型，让它保持常量性</dt>
                <dd>原子性：最小的单元，再不能分割</dd>
                <dd>常量性：状态不可变</dd>
                <dd>具有原子性的struct，不能单独修改属性，否则会把它割裂开，变成无意义的数据；所以在它诞生后，状态就一直不可变，成为常量</dd>
                <dd>这样的struct：域为readonly，没有set属性，在get属性中的引用类型成员必须被复制，只能通过构造函数初始化</dd>
            </dl>
        </li>

        <li>
            <dl>
                <dt>暴露最少的信息：最少知识原则</dt>
                <dd>类：隐藏不必要的成员
                    <ul>
                        <li><strong class="label label-info">public</strong> 完全暴露成员</li>
                        <li><strong class="label label-info">protected</strong> 只将成员暴露给子类</li>
                        <li><strong class="label label-info">private</strong> 不暴露，只为自己服务</li>
                    </ul>
                </dd>
                <dd>程序集：隐藏不必要的类
                    <ul>
                        <li><strong class="label label-info">public</strong> 给外部提供服务</li>
                        <li><strong class="label label-info">internal</strong> 为程序集内的其它类服务 / 只为实现接口</li>
                        <li><strong class="label label-info">private</strong> 内部类，只为某个类服务 / 只为实现接口</li>
                    </ul>
                </dd>
                <dd>暴露范围原则：仅暴露在必须使用到“它”的场合，一定要尽量隐藏</dd>
            </dl>
        </li>

        <li>
            <dl>
                <dt>契约 / 抽象类</dt>
                <dd>干什么：定义契约interface</dd>
                <dd>怎么干：抽象类abstract class / 对象组合</dd>
                <dd>从目的出发，两者截然不同：interface定义干什么，abstract class只是怎么干的一种方式</dd>
            </dl>
        </li>

        <li>
            <dl>
                <dt>类型 & 实例</dt>
                <dd>类型：interface, delegate, event, struct, class （描述分类）</dd>
                <dd>实例：new object() （描述个体）</dd>
                <dd>实例由变量来指代，你从什么分类角度看待它，就用什么样的变量类型（接口、父类、具体类）</dd>
                <dd>实例不会随变量类型变化</dd>
            </dl>
        </li>

        <li>
            <dl>
                <dt>接口 / 虚方法</dt>
                <dd>接口：类与类之间的契约，只定义不实现</dd>
                <dd>虚方法：父类和子类之间的契约，必须提供默认实现</dd>
            </dl>
        </li>

        <li>
            <dl>
                <dt>使用单播方式发送通知：回调机制</dt>
                <dd>给方法传递委托，就实现了回调</dd>
                <dd>类库中提供了常用的委托：Predict&lt;&gt; / Action&lt;&gt; / Func&lt;&gt; </dd>
                <dd>Predict<>：返回 bool类型，自定义 in类型</dd>
                <dd>Action<>：返回 void类型，自定义 in类型</dd>
                <dd>Func<>：自定义 out类型，自定义 in类型</dd>
            </dl>
        </li>

        <li>
            <dl>
                <dt>使用广播方式发送通知：事件机制</dt>
                <dd>定义事件的标准方式：event EventHandler&lt;TEventArgs&gt; 事件变量</dd>
                <dd>描述事件传递参数：class TEventArgs: EventArgs</dd>
                <dd>订阅事件：事件变量 += 订阅方法</dd>
                <dd>引发事件：事件变量()</dd>
            </dl>
        </li>

        <li>
            <dl>
                <dt>避免返回对成员的引用：防止被外界修改</dt>
                <dd>用接口指代内部成员：外界只使用内部成员提供的服务</dd>
                <dd>使用包装器：如ReadOnlyCollection&lt;T&gt;</dd>
            </dl>
        </li>

        <li>
            <dl>
                <dt>让自定义类型支持序列化：[Serializable] / ISerializable</dt>
                <dd>简单方式：加标记[Serializable]</dd>
                <dd>复杂方式：实现ISerializable</dd>
            </dl>
        </li>

        <li>
            <dl>
                <dt>设计Web API时选择合适的粒度</dt>
                <dd>粒度小：通信次数多，数据传输量小（client陷入频繁等待）</dd>
                <dd>粒度大：通信次数少，数据传输量大（一次等待的时间长）</dd>
                <dd>选择合适的粒度，使client每次的等待时间都适中，在合理时间内完成一件事</dd>
            </dl>
        </li>

        <li>
            <dl>
                <dt>...</dt>
                <dd></dd>
            </dl>
        </li>

        <li>
            <dl>
                <dt>...</dt>
                <dd></dd>
            </dl>
        </li>

    </ol>
</div>

<p class="alert">
    注：
    <br />
    1.参考书籍《C#高效编程改进C#代码的50个行之有效的办法(第2版) 中文版》
</p>

<a id="IEquatableCode" data-code-url="content/CSharp/IEquatableDemo.txt">标准 IEquatable&lt;T&gt; 代码</a>
<a id="IDisposableCode" data-code-url="content/CSharp/IDisposableDemo.txt">标准 IDisposable 代码</a>
