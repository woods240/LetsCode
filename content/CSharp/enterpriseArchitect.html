<div class="blackBoard">
    <ol>
        <li>
            <dl>
                <dt>本书的目的</dt>
                <dd>模式：温故而知新，提供模式列表（在实践中不断补充完善）供使用者选择</dd>
                <dd>选择：无通用解决方案，必须根据实际情况权衡抉择！</dd>
            </dl>
        </li>

        <li>
            <dl>
                <dt>架构</dt>
                <dd>最高层次的系统分解</dd>
                <dd>系统中不易改变的决定</dd>
            </dl>
        </li>

        <li>
            <dl>
                <dt>企业应用的特点</dt>
                <dd>数据
                    <ul>
                        <li><strong class="label label-info">持久化数据</strong> 数据的生命周期会比硬件、软件都要长（需要数据迁移）</li>
                        <li><strong class="label label-info">数据量大</strong> 需要设计合理的数据库模型</li>
                        <li><strong class="label label-info">高并发访问</strong> 用户数量多、使用频率高</li>
                    </ul>
                </dd>
                <dd>交互界面
                    <ul>
                        <li><strong class="label label-info">交互界面多</strong> 为满足不同的使用目的，数据需要多种表现形式</li>
                    </ul>
                </dd>
                <dd>系统集成
                    <ul>
                        <li><strong class="label label-info">集成环境差</strong> 需要将各个时期、不同技术构建的系统，集成在一起为企业服务</li>
                    </ul>
                </dd>
                <dd>业务逻辑
                    <ul>
                        <li><strong class="label label-info">逻辑复杂、易变</strong> 由于商业原因，有很多特殊情况</li>
                    </ul>
                </dd>
                <dd>规模
                    <ul>
                        <li><strong class="label label-info">不固定</strong> 既有大型应用，也有小型应用</li>
                    </ul>
                </dd>
            </dl>
        </li>

        <li>
            <dl>
                <dt>性能衡量</dt>
                <dd><strong class="label label-info">响应时间</strong> 一次系统交互用掉的时间（输入&rarr;输出，耗费的时间）</dd>
                <dd><strong class="label label-info">等待时间</strong> 什么都不做时，系统的响应时间（远程系统中的大问题）</dd>
                <dd><strong class="label label-info">响应性</strong> 用户对系统响应的感受（进度提示等，可以提高这种用户体验）</dd>
                <dd><strong class="label label-info">吞吐率</strong> 单位时间内，系统的吞吐量（输出）</dd>
                <dd><strong class="label label-info">负载</strong> 当前接收的用户请求数量，常作为其它指标的背景（输入）</dd>
                <dd><strong class="label label-info">容量</strong> 最大有效负载（最大输入，超出就不能承受了）</dd>
                <dd><strong class="label label-info">负载敏感度</strong> 响应时间随负载变化的幅度（输入对输出在时间方面的影响）</dd>
                <dd><strong class="label label-info">效率</strong> 性能除以资源，反应系统整合资源的能力</dd>
                <dd><strong class="label label-info">可伸缩性</strong> 系统性能对资源的依赖性（越强越好）</dd>
                <dd>性能是从多个角度来衡量的，现实中根据系统的特点，提高某些方面就够了</dd>
            </dl>
        </li>

        <li>
            <dl>
                <dt>分层</dt>
                <dd>职责分配
                    <ul>
                        <li><strong class="label label-info">职责</strong> 每一层的工作边界，不能多干，也不能少干</li>
                        <li><strong class="label label-info">接口</strong> 描述职责，既明确自己要干什么，同时告诉别人能干什么</li>
                        <li><strong class="label label-info">接口主导者</strong> 使用者 / 实现者 / 第三方</li>
                    </ul>
                </dd>
                <dd>优点
                    <ul>
                        <li><strong class="label label-info">分离关注点</strong> 更专注，更容易把事情做好（不会顾此失彼）</li>
                        <li><strong class="label label-info">标准化</strong> 接口就是每层工作的标准</li>
                        <li><strong class="label label-info">替换</strong> 一个标准可以有多种实现，它们可以互相替换</li>
                    </ul>
                </dd>
                <dd>缺点
                    <ul>
                        <li><strong class="label label-info">级联修改</strong> 顶层接口的扩展，需要扩展底层接口来支持</li>
                        <li><strong class="label label-info">性能</strong> 层次过多会带来“沟通”的成本</li>
                    </ul>
                </dd>
                <dd>三个基本层次
                    <ul>
                        <li><strong class="label label-info">表现层</strong> 负责界面交互</li>
                        <li><strong class="label label-info">业务层（系统核心）</strong> 负责处理业务逻辑，主导与表现层、数据层的接口</li>
                        <li><strong class="label label-info">数据层</strong> 负责数据访问</li>
                    </ul>
                </dd>
                <dd>物理节点分布
                    <ul>
                        <li><strong class="label label-info">客户机</strong> 响应性好，维护复杂</li>
                        <li><strong class="label label-info">服务器</strong> 维护方便，响应性差</li>
                        <li><strong class="label label-info">性能平衡</strong> 哪一层耗费的计算资源多，就多分配节点（计算单元）</li>
                    </ul>
                </dd>
            </dl>
        </li>

        <li>
            <dl>
                <dt>组织领域逻辑</dt>
                <dd>事务脚本
                    <ul>
                        <li><strong class="label label-info">面向过程</strong> 由用户的一个动作，引发一系列步骤</li>
                        <li><strong class="label label-info">优点</strong> 从一个业务点思考，思路顺畅、简单易理解</li>
                        <li><strong class="label label-info">缺点</strong> 业务复杂时，会出现很多重复逻辑</li>
                    </ul>
                </dd>
                <dd>表模块
                    <ul>
                        <li><strong class="label label-info">面向表数据</strong> 围绕数据库中的表，将对应操作封装到表模块中</li>
                        <li><strong class="label label-info">优点</strong> 直接访问数据</li>
                        <li><strong class="label label-info">缺点</strong> 业务复杂时，不容易处理</li>
                    </ul>
                </dd>
                <dd>领域模型
                    <ul>
                        <li><strong class="label label-info">面向对象</strong> 将业务逻辑作为职责，组织和分配给不同的对象</li>
                        <li><strong class="label label-info">优点</strong> 处理复杂的业务；逻辑没有重复</li>
                        <li><strong class="label label-info">缺点</strong> 从业务的全局思考；不容易将业务实体映射到数据库</li>
                    </ul>
                </dd>
            </dl>
        </li>

        <li>
            <dl>
                <dt>数据访问</dt>
                <dd>架构模式
                    <ul>
                        <li><strong class="label label-info">行数据入口</strong> 数据访问面向业务实体，返回对象</li>
                        <li><strong class="label label-info">表数据入口</strong> 数据访问面向表，返回记录集</li>
                        <li><strong class="label label-info">数据映射器</strong> 对象关系映射 ORM</li>
                    </ul>
                </dd>
                <dd>对象组合映射
                    <ul>
                        <li><strong class="label label-info">一对多</strong> 类通过属性引用；表通过外键连接</li>
                        <li><strong class="label label-info">多对多</strong> 两个类互相引用；增加一张表，关联两表的主键</li>
                    </ul>
                </dd>
                <dd>类继承映射
                    <ul>
                        <li><strong class="label label-info">单表继承</strong> 用一张表包含继承家族的所有字段【浪费空间，很多空字段】</li>
                        <li><strong class="label label-info">具表继承</strong> 每张具体表对应一个（继承了的）具体类【不推荐】</li>
                        <li><strong class="label label-info">类表继承</strong> 每张表对应一个（单独定义的）类【损失性能，太多连接】</li>
                    </ul>
                </dd>
            </dl>
        </li>

        <li>
            <dl>
                <dt>Web表现</dt>
                <dd>M 模型
                    <ul>
                        <li><strong class="label label-info">数据模型</strong> 组织业务逻辑</li>
                    </ul>
                </dd>
                <dd>V 视图
                    <ul>
                        <li><strong class="label label-info">模版视图</strong> 面向Html结果，从整体到局部（先构建结果蓝图，再填充数据）</li>
                        <li><strong class="label label-info">转换视图</strong> 面向领域数据，从局部到整体（先明确数据意义，然后确定展现）</li>
                        <li><strong class="label label-info">两步视图</strong> 领域数据&rarr;表现数据&rarr;Html结果</li>
                    </ul>
                </dd>
                <dd>C 控制器
                    <ul>
                        <li><strong class="label label-info">页面控制器</strong> 为特定页面或动作处理请求（响应单个请求）</li>
                        <li><strong class="label label-info">前端控制器</strong> 为一个站点处理所有请求（做认证、授权等通用的工作）</li>
                    </ul>
                </dd>
            </dl>
        </li>

        <li>
            <dl>
                <dt>并发</dt>
                <dd>并发的本质问题（正确性）
                    <ul>
                        <li><strong class="label label-info">更新丢失</strong> 两个人修改同一版本的文件，后提交的覆盖了先提交的，致使第一个更新丢失</li>
                        <li><strong class="label label-info">不一致读</strong> 两份数据有关系，读取第一份数据后，执行某操作修改了两份数据，然后读取第二份数据，致使两份份数据的版本不一致</li>
                    </ul>
                </dd>
                <dd>执行环境
                    <ul>
                        <li><strong class="label label-info">进程</strong> 一段程序的执行过程，将正在处理的数据与外部隔离开</li>
                        <li><strong class="label label-info">线程</strong> 进程中某个单一顺序的控制流，共享进程资源</li>
                    </ul>
                </dd>
                <dd>避免并发的策略
                    <ul>
                        <li><strong class="label label-info">隔离</strong> 划分数据，使一片数据在一段时间，只能被一个线程访问</li>
                        <li><strong class="label label-info">不变性</strong> 识别只读数据，对它们不用考虑并发问题</li>
                    </ul>
                </dd>
                <dd>必须面对并发时的策略
                    <ul>
                        <li><strong class="label label-info">乐观锁</strong> 允许并发访问，在更新时检测冲突（然后决定如何处理：合并、放弃、覆盖）
                            <ol>
                                <li>事后检测，适用于冲突几率低的情况</li>
                                <li>优点：并发度很高（不管三七二十一，一拥而上）</li>
                                <li>缺点：一旦由于冲突导致更新失败，要重新开始</li>
                            </ol>
                        </li>
                        <li><strong class="label label-info">悲观锁</strong> 不允许并发访问，避免冲突
                            <ol>
                                <li>事前检测，适用于冲突几率高的情况</li>
                                <li>优点：没有冲突，不影响更新</li>
                                <li>缺点：需要排队等待，效率低</li>
                                <li>独占写锁：一个人写，不考虑其它人读（并发高，但可能出现不一致读：写的时候可以读）</li>
                                <li>独占读锁：一个人读/一个人读写（并发低，访问效率太低）</li>
                                <li>读/写锁：一个人写/多个人读（并发适中，但实现麻烦）</li>
                                <li>锁管理对象：负责锁的获取和释放</li>
                            </ol>
                        </li>
                    </ul>
                </dd>
            </dl>
        </li>

        <li>
            <dl>
                <dt>事务：不论成功失败，作为一个整体进行工作</dt>
                <dd>ACID
                    <ul>
                        <li><strong class="label label-info">原子性 Atomicity</strong> 所有步骤必须全部成功，否则工作回滚到初始状态</li>
                        <li><strong class="label label-info">一致性 Consistency</strong> 事务结果只有两个状态：成功后的状态，执行前的状态</li>
                        <li><strong class="label label-info">隔离性 Isolation</strong> 事务完成后，它的结果才可见</li>
                        <li><strong class="label label-info">持久性 Durability</strong> 事务的结果是永久性的，“在任何系统崩溃的状态下都能保存下来”</li>
                    </ul>
                </dd>
            </dl>
        </li>

        <li>
            <dl>
                <dt>会话状态</dt>
                <dd>会话：客户端与服务器端的完整交互过程，由多个请求组成</dd>
                <dd>存储会话状态的位置（StateServer较常用）
                    <ul>
                        <li><strong class="label label-info">客户端</strong> Cookie / Url / HiddenField【小数据量、跨少量请求、不安全】</li>
                        <li><strong class="label label-info">服务器端</strong> InProc【容易丢失、不支持集群和故障恢复】</li>
                        <li><strong class="label label-info">第三方</strong> StateServer / SQLServer【需要序列化】</li>
                        <li>Asp.Net中，仅需要在<ins><a href="#SessionConfig">Web.config</a></ins>中配置，详情参考<a href="http://msdn.microsoft.com/zh-cn/library/ms178586(v=vs.80).aspx" target="_blank">MSDN</a></li>
                    </ul>
                </dd>
            </dl>
        </li>

        <li>
            <dl>
                <dt>分布策略</dt>
                <dd>过程调用的基本特点
                    <ul>
                        <li>进程内的过程调用非常快</li>
                        <li>跨进程的调用慢一个数量级</li>
                        <li>跨机器的调用又要慢一个数量级，具体取决于网络</li>
                    </ul>
                </dd>
                <dd>接口设计
                    <ul>
                        <li><strong class="label label-info">本地接口</strong> 细粒度，单一职责</li>
                        <li><strong class="label label-info">远程接口</strong> 粗粒度，为了减少方法调用次数</li>
                        <li><strong class="label label-info">集群系统</strong> 将程序复制到多个处理器上，本地接口设计 + 多处理器资源</li>
                    </ul>
                </dd>
                <dd>分布接口实现
                    <ul>
                        <li><strong class="label label-info">Web Service</strong> 跨平台，但数据转换开销大</li>
                        <li><strong class="label label-info">系统的远程调用机制</strong> 开销小，但平台必须相同</li>
                    </ul>
                </dd>
                <dd>远程外观
                    <ul>
                        <li><strong class="label label-info">粗粒度接口</strong> 把几件事合成一件来干</li>
                        <li><strong class="label label-info">数据传输对象</strong> 把几件事的结果组合到一起来传递</li>
                    </ul>
                </dd>
                <dd>策略：先按细粒度进行设计，然后根据远程过程的需要，包装远程外观（粗粒度接口）</dd>
            </dl>
        </li>

        <li>
            <dl>
                <dt>通盘考虑</dt>
                <dd>架构思路
                    <ul>
                        <li><strong class="label label-info">定义服务层</strong> 分析客户需求，定义事务脚本</li>
                        <li><strong class="label label-info">实现服务层，定义领域层接口</strong> 分析事务脚本的具体步骤，设计领域模型组织所有步骤</li>
                        <li><strong class="label label-info">实现领域层，定义数据层接口</strong> 分析领域模型的存储需求，定义行数据入口并设计逻辑数据模型</li>
                        <li><strong class="label label-info">实现数据层接口，创建物理数据库</strong> 根据逻辑数据模型设计物理数据模型，并实现行数据入口</li>
                    </ul>
                </dd>
                <dd>细节问题
                    <ul>
                        <li><strong class="label label-info">如何分层？</strong> 哪一层复杂，就将职责切分，由多个层分工协作</li>
                        <li><strong class="label label-info">提高性能？</strong> 哪个逻辑复杂，就将多个步骤合并，由一个粗粒度接口直接完成【类似直辖市】</li>
                        <li><strong class="label label-info">如何定义Model？</strong> Model是3层之间用于沟通的数据容器，按照业务接口和数据接口的需要来定义</li>
                    </ul>
                </dd>
            </dl>
        </li>

        <li>
            <dl>
                <dt>基本模式</dt>
                <dd>延迟加载：一个对象，不包含数据，但知道怎样获取这些数据
                    <ul>
                        <li><strong class="label label-info">问题背景</strong> 加载一个对象时，引起相关数据的加载，相当费资源且使用率很低</li>
                        <li><strong class="label label-info">使用时机</strong> 费资源、且使用率很低的数据</li>
                        <li><strong class="label label-info">方法</strong> 设立一个标志（null/0/...），以便使需要数据的时候再加载</li>
                    </ul>
                </dd>
                <dd>预加载：一个对象，加载多个对象需要的数据
                    <ul>
                        <li><strong class="label label-info">问题背景</strong> 多个对象使用的数据在同一个地方，单独加载速度很慢</li>
                        <li><strong class="label label-info">使用时机</strong> 加载很慢、且可以同时加载的数据</li>
                        <li><strong class="label label-info">方法</strong> 用一个类，同时加载所有的数据，再分别筛选，交给每个对象使用</li>
                    </ul>
                </dd>
                <dd>入口：一个对象，封装对资源的访问
                    <ul>
                        <li><strong class="label label-info">问题背景</strong> 访问任何资源，都要学习其API，面对不可避免的复杂性</li>
                        <li><strong class="label label-info">使用时机</strong> 不熟悉、且复杂的API</li>
                        <li><strong class="label label-info">方法</strong> 用一个类封装资源的API代码，将其转换为自己习惯的接口</li>
                    </ul>
                </dd>
                <dd>映射器：一个对象，在两个独立的对象之间建立通信
                    <ul>
                        <li><strong class="label label-info">问题背景</strong> 两个子系统间没有依赖关系，要在它们之间建立通信</li>
                        <li><strong class="label label-info">使用时机</strong> 子系统之间交互复杂，且交互独立于各自的主要目标</li>
                        <li><strong class="label label-info">方法</strong> 书中无详细介绍</li>
                    </ul>
                </dd>
                <dd>层超类型：一个类型，充当一层中所有类型的超类型
                    <ul>
                        <li><strong class="label label-info">问题背景</strong> 一层中所有的对象都具有某些方法，希望可以复用它们</li>
                        <li><strong class="label label-info">使用时机</strong> 为了实现这一层的职责，需要的公共方法</li>
                        <li><strong class="label label-info">方法</strong> 自顶向下设计公共方法 / 从底向上提取公共方法</li>
                    </ul>
                </dd>
                <dd>分离接口：将接口的定义与实现分离，单独放在一个包中
                    <ul>
                        <li><strong class="label label-info">问题背景</strong> 使用者只依赖于接口，不依赖于具体实现</li>
                        <li><strong class="label label-info">使用时机</strong> 接口有多种实现 / 主导接口的人不是实现者</li>
                        <li><strong class="label label-info">方法</strong> 使用 interface / abstract class 定义接口包</li>
                    </ul>
                </dd>
                <dd>注册表：将全局数据注册到一个对象中（其实就是将获取数据的方法集中到一起）
                    <ul>
                        <li><strong class="label label-info">问题背景</strong> 需要使用一系列数据，但不知道从哪里获取它们</li>
                        <li><strong class="label label-info">使用时机</strong> 数据的作用域是全局、且使用频繁</li>
                        <li><strong class="label label-info">方法</strong> 使用 静态方法 / Singleton实例 实现注册表接口</li>
                    </ul>
                </dd>
                <dd>插件：在运行时根据接口自动连接实现
                    <ul>
                        <li><strong class="label label-info">问题背景</strong> 接口在多种环境下对应多种实现，希望在特定环境下自动连接对应的实现</li>
                        <li><strong class="label label-info">使用时机</strong> 在不同环境下，要求不同的接口实现</li>
                        <li><strong class="label label-info">方法</strong> 使用插件工厂 从程序集反射 / 读取配置文件 来映射接口和实现</li>
                    </ul>
                </dd>
                <dd>服务桩（模拟对象）：在测试时，模拟所依赖的 服务 / 对象
                    <ul>
                        <li><strong class="label label-info">问题背景</strong> 所依赖的服务尚未开发或不容易得到，延缓了开发进程</li>
                        <li><strong class="label label-info">使用时机</strong> 对某一服务的依赖，妨碍了开发和测试</li>
                        <li><strong class="label label-info">方法</strong> 先分离服务接口，然后用简单的代码模拟实现（可以使用Mock工具）</li>
                    </ul>
                </dd>
                <dd>记录集（DataSet）：在内存中，将数据用关系表格来组织
                    <ul>
                        <li><strong class="label label-info">问题背景</strong> 某些环境需要用关系表格描述的数据结构</li>
                        <li><strong class="label label-info">使用时机</strong> 某个环境依赖于记录集结构、并将其作为操控数据的通用方法</li>
                        <li><strong class="label label-info">方法</strong> 先分离服务接口，然后用简单的代码模拟实现（可以使用Mock工具）</li>
                    </ul>
                </dd>
            </dl>
        </li>

    </ol>
</div>

<p class="alert">
    作者箴言：
    <br />
    “我并不知道所有的答案，也不知道你的问题。应该用这些建议去推动你思考，而不是代替你去思考。最终决策的应该是你，最终享受乐趣或承担痛苦的也是你。”
</p>

<a id="SessionConfig" data-code-url="content/CSharp/SessionConfig.txt">配置Session存储方式</a>