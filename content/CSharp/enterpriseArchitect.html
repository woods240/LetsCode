<div class="blackBoard">
    <ol>
        <li>
            <dl>
                <dt>本书的目的</dt>
                <dd>模式：温故而知新，提供模式列表（在实践中不断补充完善）供使用者选择</dd>
                <dd>选择：无通用解决方案，必须根据实际情况权衡抉择！</dd>
            </dl>
        </li>

        <li>
            <dl>
                <dt>架构</dt>
                <dd>最高层次的系统分解</dd>
                <dd>系统中不易改变的决定</dd>
            </dl>
        </li>

        <li>
            <dl>
                <dt>企业应用的特点</dt>
                <dd>数据
                    <ul>
                        <li><strong class="label label-info">持久化数据</strong> 数据的生命周期会比硬件、软件都要长（需要数据迁移）</li>
                        <li><strong class="label label-info">数据量大</strong> 需要设计合理的数据库模型</li>
                        <li><strong class="label label-info">高并发访问</strong> 用户数量多、使用频率高</li>
                    </ul>
                </dd>
                <dd>交互界面
                    <ul>
                        <li><strong class="label label-info">交互界面多</strong> 为满足不同的使用目的，数据需要多种表现形式</li>
                    </ul>
                </dd>
                <dd>系统集成
                    <ul>
                        <li><strong class="label label-info">集成环境差</strong> 需要将各个时期、不同技术构建的系统，集成在一起为企业服务</li>
                    </ul>
                </dd>
                <dd>业务逻辑
                    <ul>
                        <li><strong class="label label-info">逻辑复杂、易变</strong> 由于商业原因，有很多特殊情况</li>
                    </ul>
                </dd>
                <dd>规模
                    <ul>
                        <li><strong class="label label-info">不固定</strong> 既有大型应用，也有小型应用</li>
                    </ul>
                </dd>
            </dl>
        </li>

        <li>
            <dl>
                <dt>性能衡量</dt>
                <dd>响应时间：一次系统交互用掉的时间（输入&rarr;输出，耗费的时间）</dd>
                <dd>等待时间：什么都不做时，系统的响应时间（远程系统中的大问题）</dd>
                <dd>响应性：用户对系统响应的感受（进度提示等，可以提高这种用户体验）</dd>
                <dd>吞吐率：单位时间内，系统的吞吐量（输出）</dd>
                <dd>负载：当前接收的用户请求数量，常作为其它指标的背景（输入）</dd>
                <dd>容量：最大有效负载（最大输入，超出就不能承受了）</dd>
                <dd>负载敏感度：响应时间随负载变化的幅度（输入对输出在时间方面的影响）</dd>
                <dd>效率：性能除以资源，反应系统整合资源的能力</dd>
                <dd>可伸缩性：系统性能对资源的依赖性（越强越好）</dd>
                <dd>性能是从多个角度来衡量的，现实中根据系统的特点，提高某几个方面就够了</dd>
            </dl>
        </li>

        <li>
            <dl>
                <dt>分层</dt>
                <dd>职责分配
                    <ul>
                        <li><strong class="label label-info">职责</strong> 每一层的工作边界，不能多干，也不能少干</li>
                        <li><strong class="label label-info">接口</strong> 描述职责，既明确自己要干什么，同时告诉别人能干什么</li>
                        <li><strong class="label label-info">接口主导者</strong> 使用者 / 实现者 / 第三方</li>
                    </ul>
                </dd>
                <dd>优点
                    <ul>
                        <li><strong class="label label-info">分离关注点</strong> 更专注，更容易把事情做好（不会顾此失彼）</li>
                        <li><strong class="label label-info">标准化</strong> 接口就是每层工作的标准</li>
                        <li><strong class="label label-info">替换</strong> 一个标准可以有多种实现，它们可以互相替换</li>
                    </ul>
                </dd>
                <dd>缺点
                    <ul>
                        <li><strong class="label label-info">级联修改</strong> 顶层接口的扩展，需要扩展底层接口来支持</li>
                        <li><strong class="label label-info">性能</strong> 层次过多会带来“沟通”的成本</li>
                    </ul>
                </dd>
                <dd>三个基本层次
                    <ul>
                        <li><strong class="label label-info">表现层</strong> 负责界面交互</li>
                        <li><strong class="label label-info">业务层（系统核心）</strong> 负责处理业务逻辑，主导与表现层、数据层的接口</li>
                        <li><strong class="label label-info">数据层</strong> 负责数据访问</li>
                    </ul>
                </dd>
                <dd>物理节点分布
                    <ul>
                        <li><strong class="label label-info">客户机</strong> 响应性好，维护复杂</li>
                        <li><strong class="label label-info">服务器</strong> 维护方便，响应性差</li>
                        <li><strong class="label label-info">性能平衡</strong> 哪一层耗费的计算资源多，就多分配节点（计算单元）</li>
                    </ul>
                </dd>
            </dl>
        </li>

        <li>
            <dl>
                <dt>组织领域逻辑</dt>
                <dd>事务脚本
                    <ul>
                        <li><strong class="label label-info">面向过程</strong> 由用户的一个动作，引发一系列步骤</li>
                        <li><strong class="label label-info">优点</strong> 从一个业务点思考，思路顺畅、简单易理解</li>
                        <li><strong class="label label-info">缺点</strong> 业务复杂时，会出现很多重复逻辑</li>
                    </ul>
                </dd>
                <dd>表模块
                    <ul>
                        <li><strong class="label label-info">面向表数据</strong> 围绕数据库中的表，将对应操作封装到表模块中</li>
                        <li><strong class="label label-info">优点</strong> 直接访问数据</li>
                        <li><strong class="label label-info">缺点</strong> 业务复杂时，不容易处理</li>
                    </ul>
                </dd>
                <dd>领域模型
                    <ul>
                        <li><strong class="label label-info">面向对象</strong> 将业务逻辑作为职责，组织和分配给不同的对象</li>
                        <li><strong class="label label-info">优点</strong> 处理复杂的业务；逻辑没有重复</li>
                        <li><strong class="label label-info">缺点</strong> 从业务的全局思考；不容易将业务实体映射到数据库</li>
                    </ul>
                </dd>
            </dl>
        </li>

        <li>
            <dl>
                <dt>数据访问</dt>
                <dd>架构模式
                    <ul>
                        <li><strong class="label label-info">行数据入口</strong> 数据访问面向业务实体，返回对象</li>
                        <li><strong class="label label-info">表数据入口</strong> 数据访问面向表，返回记录集</li>
                        <li><strong class="label label-info">数据映射器</strong> 对象关系映射 ORM</li>
                    </ul>
                </dd>
                <dd>对象组合映射
                    <ul>
                        <li><strong class="label label-info">一对多</strong> 类通过属性引用；表通过外键连接</li>
                        <li><strong class="label label-info">多对多</strong> 两个类互相引用；增加一张表，关联两表的主键</li>
                    </ul>
                </dd>
                <dd>类继承映射
                    <ul>
                        <li><strong class="label label-info">单表继承</strong> 用一张表包含继承家族的所有字段【浪费空间，很多空字段】</li>
                        <li><strong class="label label-info">具表继承</strong> 每张具体表对应一个（继承了的）具体类【不推荐】</li>
                        <li><strong class="label label-info">类表继承</strong> 每张表对应一个（单独定义的）类【损失性能，太多连接】</li>
                    </ul>
                </dd>
            </dl>
        </li>

        <li>
            <dl>
                <dt>并发</dt>
                <dd>并发的本质问题（正确性）
                    <ul>
                        <li><strong class="label label-info">更新丢失</strong> 两个人修改同一版本的文件，后提交的覆盖了先提交的，致使第一个更新丢失</li>
                        <li><strong class="label label-info">不一致读</strong> 在两个时间点读取两份数据，中间执行的操作同时更新两份数据，致使两份数据的版本不一致</li>
                    </ul>
                </dd>
                <dd>执行环境
                    <ul>
                        <li><strong class="label label-info">进程</strong> 一段程序的执行过程，将正在处理的数据与外部隔离开</li>
                        <li><strong class="label label-info">线程</strong> 进程中某个单一顺序的控制流，共享进程资源</li>
                    </ul>
                </dd>
                <dd>避免并发的策略
                    <ul>
                        <li><strong class="label label-info">隔离</strong> 划分数据，使一片数据在一段时间，只能被一个线程访问</li>
                        <li><strong class="label label-info">不变性</strong> 识别只读数据，对它们不用考虑并发问题</li>
                    </ul>
                </dd>
                <dd>必须面对并发时的策略
                    <ul>
                        <li><strong class="label label-info">乐观锁</strong> 允许并发，更新时检测冲突，然后决定如何处理（合并、放弃、覆盖）</li>
                        <li><strong class="label label-info">悲观锁</strong> 不允许并发，避免冲突，只能被一个线程访问</li>
                    </ul>
                </dd>
            </dl>
        </li>

        <li>
            <dl>
                <dt>事务：不论成功失败，作为一个整体进行工作</dt>
                <dd>ACID
                    <ul>
                        <li><strong class="label label-info">原子性 Atomicity</strong> 所有步骤必须全部成功，否则工作回滚到初始状态</li>
                        <li><strong class="label label-info">一致性 Consistency</strong> 事务的结果只有两个状态：成功后的状态，执行前的状态</li>
                        <li><strong class="label label-info">隔离性 Isolation</strong> 事务完成后，它的结果才可见</li>
                        <li><strong class="label label-info">持久性 Durability</strong> 事务的结果是永久性的，“在任何系统崩溃的状态下都能保存下来”</li>
                    </ul>
                </dd>
                <dd>。。。</dd>
            </dl>
        </li>

    </ol>
</div>
